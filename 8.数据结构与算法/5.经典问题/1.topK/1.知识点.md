#### 1. 描述
问题: top(k) 问题就是找出在目标集合中最大(小的)k个数。
所有方法: 排序、部分排序、堆、分治法

#### 2. 方法
##### 1. 排序法
- 对所有数排序，选前k个数

> 时间复杂度: 如果用最块的快排，那么排序的时间复杂度就是 O(nlgn)，然后再遍历前 k 个数字，所以总的时间复杂度是 O(nlgn) + o(k) = o(nlogn)

##### 2. 部分排序法: 没必要对所有元素排序。
- 先遍历 n 个数，把最开始的 k 个数存入大小为 k 的数组
- 对k个数使用选择或者查找排序找到k个元素中的最小值 kmin(找最小值的时间复杂度为 O(k))
- 继续遍历剩下的数字，如果比kmin 更大，那么用 x 替换 kmin，并继续找 k 个元素中的最小值 kmin。如果 x 比 kmin 还小，那么它不可能是最大的 k 个数之一，所以继续遍历
> 时间复杂度: 每次遍历的时候，更新数组时的时间复杂度为 o(k)，不更新的时间复杂度是 0，所以总的时间复杂度是 n * O(k) = o(n * k)

##### 3. 使用最小堆: 维护容量为 k 的最小堆，原理与 2 类似
- 使用容量为 k 的最小堆存储最开始的 k 个数，堆中的3元素是有序的，堆顶元素是最小值
- 遍历剩余的 n-k 个元素，如果元素 x 大于堆顶元素，那么用 x 替代堆顶元素，并调整堆，时间复杂度为 O(lgk)，如果元素x 小于堆顶元素，那么它不可能是 topk，继续遍历
> 时间复杂度: 每次调整时的时间复杂度是 O(lgk)，所以总的时间复杂度是 n * o(lgk) = o(nlgk)

##### 4. 分治法: 基于快排的分治思想
- 使用第一元素来分割整个序列
- 如果这个元素的位置是大于k的，则说明 topk 是在前半个序列中，继续分割前半个序列。如果这个元素的位置是小于 k 的，则说明 topk 是在后半个序列中，则继续分割后半个序列。
- 直到某次分割，元素正好处于第 k 个位置，那么就第k 个元素以及之前的元素就是 topk
> 平均时间复杂度: o(n)

#### 3. 总结
总体来说，需要记住的主要是**最小堆法和分治法**。分治法的平均时间复杂度比较好，但是缺点是需要加载所有数据，那么在数据量非常大的情况下，如果内存不能一次性加载所有数据，那么分治法就需要分段进行计算并汇总结果再进行计算，在考虑磁盘IO的时间损耗的情况下，最小堆的方法反而可能更快