// 问题: top(k) 问题就是找出在目标集合中最大(小的)k个数。
// 所有方法: 排序、部分排序、堆、分治法
// 1. 排序法
// 1.1 对所有数排序，选前k个数
// 时间复杂度: 如果用最块的快排，那么排序的时间复杂度就是 O(nlgn)，然后再遍历前 k 个数字，所以总的时间复杂度是 O(nlgn) + o(k) = o(nlogn)

// 2. 部分排序法: 没必要对所有元素排序。
// 2.1 先遍历 n 个数，把最开始的 k 个数存入大小为 k 的数组
// 2.2 对k个数使用选择或者查找排序找到k个元素中的最小值 kmin(找最小值的时间复杂度为 O(k))
// 2.3 继续遍历剩下的数字，如果比kmin 更大，那么用 x 替换 kmin，并继续找 k 个元素中的最小值 kmin。如果 x 比 kmin 还小，那么它不可能是最大的 k 个数之一，所以继续遍历
// 时间复杂度: 每次遍历的时候，更新数组时的时间复杂度为 o(k)，不更新的时间复杂度是 0，所以总的时间复杂度是 n * O(k) = o(n * k)

// 3. 使用最小堆: 维护容量为 k 的最小堆，原理与 2 类似
// 3.1 使用容量为 k 的最小堆存储最开始的 k 个数，堆中的3元素是有序的，堆顶元素是最小值
// 3.2 遍历剩余的 n-k 个元素，如果元素 x 大于堆顶元素，那么用 x 替代堆顶元素，并调整堆，时间复杂度为 O(lgk)，如果元素x 小于堆顶元素，那么它不可能是 topk，继续遍历
// 时间复杂度: 每次调整时的时间复杂度是 O(lgk)，所以总的时间复杂度是 n * o(lgk) = o(nlgk)

// 4. 分治法: 基于快排的分治思想
// 4.1 使用第一元素来分割整个序列