### 1. 事件循环线程与工作线程池的线程
Node 是用很少的线程来处理大量客户端请求的。

Node中，有两种类型的线程，一个事件循环线程(也就是主线程、事件线程)。另外就是在工作线程池里的 k 个工作线程。

如果一个线程执行一个回调函数（事件轮询线程）或者任务（工作线程）需要耗费很长时间，我们称之为“阻塞”。 当一个线程在处理某一个客户端请求时被阻塞了，它就无法处理其它客户端的请求了。

事件循环线程和工作线程都不能阻塞，否则会有性能和安全性问题：
- 性能： 如果在任意类型的线程上频繁处理繁重的任务，那么服务器的吞吐量会减少，而且可能是大大减少
- 安全性：如果对于特定输入，某种类型线程可能被阻塞，那么攻击者可以通过构造类似这样的恶意输入故意让线程阻塞，这样其他客户端的请求得不到响应，就是拒绝服务攻击了


### 2. 运行在事件循环线程(主线程)上的代码
1. 当 Node 程序运行时，程序首先完成初始化部分，即处理 require 加载的模块和注册事件回调。 
2. 然后，Node 应用程序进入事件循环阶段，通过执行对应回调函数来对客户端请求做出回应。 
3. 此回调将同步执行，并且可能在完成之后继续注册新的异步请求。 这些异步请求的回调也会在事件轮询线程中被处理。

事件循环线程执行事件的回调函数，并且负责处理类似网络I/O的非阻塞异步请求

### 3. 运行在工作线程池的代码

Node 的工作线程池是通过 libuv (相关文档) 来实现的，它对外提供了一个通用的任务处理 API。

Node 使用工作线程池来处理高成本的任务，包括一些操作系统没有提供的非阻塞版本的 IO 操作，以及一些 CPU 密集型任务。

如下API用到了工作线程池：
- IO密集型任务
  1. DNS: dns.lookup(), dns.lookupService()
  2. 文件系统，所有文件系统 API，除了 fs.FSWatcher() 和显式同步调用的 API，都使用 libuv 的线程池
- CPU 密集型任务
  1. Crypto: crypto.pbkdf2()，crypto.randomBytes()，crypto.randomFill()
  2. Zilb: 所有 Zlib 相关函数，除那些显式同步调用的 API 之外，都适用 libuv 的线程池。


当你在事件轮询线程的一个回调中调用这些 API 时，事件轮询线程将不得不为此花费少量的额外开销，因为它必须要进入对应 API 与 C++ 桥接通讯的 Node C++ binding 中，从而向工作线程池提交一个任务。 和整个任务的成本相比，这些开销微不足道。